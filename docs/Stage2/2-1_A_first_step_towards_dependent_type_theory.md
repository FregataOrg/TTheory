### ステージ2: 依存型と証明支援系Coq入門

#### 1. 依存型理論への第一歩

ステージ1では、単純型付きラムダ計算（STLC）を学びました。STLCでは、`A -> B` のように、関数の引数の型と返り値の型は固定されていました。これはプログラムの安全性を保証する上で大きな一歩でしたが、その表現力には限界がありました。例えば、「要素数`n`のリスト」のように、値（`n`）によって型そのものが決まるような状況を直接表現することはできません。

この限界を打ち破るのが**依存型 (Dependent Types)** です。これは文字通り、**型が値に依存することを許す**という、非常に強力なアイデアです。依存型を導入することで、型理論の表現力は飛躍的に向上し、プログラムの性質をより精密に記述したり、数学の命題をより直接的に表現したりすることが可能になります。

このセクションでは、依存型理論の基本的な構成要素である**Π型 (パイ型)** と**Σ型 (シグマ型)** を学びます。これらは、STLCにおける関数型 (`->`) と積型 (`×`) を、依存型を持つように一般化したものと考えることができます。

---

#### 2.1 依存型とは何か？

**依存型**とは、その定義の中に**値（項）**を含むことができる型のことです。

最も有名で直観的な例は、**長さnのベクトル（あるいはリスト）**の型です。

* STLCの世界では、`List<Integer>` のように「整数のリスト」という型は表現できても、そのリストの**長さ**を型の一部に含めることはできませんでした。長さが`3`のリストも`5`のリストも、同じ `List<Integer>` 型です。
* 依存型理論の世界では、`Vec A n` という型を考えることができます。これは「**型`A`の要素からなる、長さが自然数`n`のベクトル**」の型です。

この `Vec A n` という型は、型`A`だけでなく、**値`n`にも依存**しています。
* `Vec Integer 3` は、長さ3の整数ベクトルの型です。 `[1, 2, 3]` はこの型の項です。
* `Vec Integer 5` は、長さ5の整数ベクトルの型です。 `[1, 2, 3, 4, 5]` はこの型の項です。
* `[1, 2, 3]` は `Vec Integer 5` という型を持ちません。これは**型エラー**となります。

このように、値に関する情報（ここではベクトルの長さ）を型システムに持ち込むことで、プログラムの性質をより厳密に記述し、コンパイル時に検証することが可能になります。例えば、「2つのベクトルを連結する関数`append`」を考えたとき、その型を次のように宣言できます。

`append : Vec A n -> Vec A m -> Vec A (n + m)`

この型シグネチャは、「長さ`n`のベクトルと長さ`m`のベクトルを受け取ったら、必ず長さ`n+m`のベクトルを返す」という関数の仕様そのものを表現しています。もし実装がこの仕様を満たしていなければ、型エラーとなり、プログラムはコンパイルを通りません。これにより、バグの多くを未然に防ぐことができるのです。

---

#### 2.2 Π型 (Dependent Function Types)

**Π型 (パイがた)** は、依存型を持つ関数、すなわち**返り値の型が引数の値に依存するような関数**の型です。`Πx:A. B(x)` と表記されます。

* **`x:A`**: 関数の引数 `x` とその型 `A` を宣言しています。
* **`B(x)`**: 返り値の型です。この型 `B` が引数の値 `x` に応じて変化する可能性があることを `B(x)` と表記しています。

**単純な関数型 `->` との関係**

STLCで学んだ単純な関数型 `A -> B` は、Π型の特別な場合と見なすことができます。つまり、返り値の型 `B` が引数 `x` の値に**依存しない**場合です。

$$A \rightarrow B \equiv \Pi x:A. B \quad (\text{ただし、} B \text{は} x \text{に依存しない})$$

**カリー・ハワード同型対応: 全称量化 (∀)**

Π型は、論理における**全称量化子 (∀, "for all")** に対応します。

`Πx:A. B(x)` という型を持つ項（関数）を構築することは、
**「全ての `x:A` について、命題 `B(x)` が成り立つ」(`∀x:A. B(x)`)**
という命題を証明することに対応します。

なぜなら、この型の関数は、どんな `x:A` を与えられても、それに対応する `B(x)` 型の値を返すことができるプログラムだからです。これは、「どんな `x` を持ってきても、それに対する `B(x)` の証明を構成できます」という構成的な証明そのものなのです。

**例:**
* `zero_vec` という、「自然数`n`を受け取り、`n`個のゼロが入ったベクトルを返す関数」を考えます。この関数の型は `Πn:Nat. Vec Integer n` となります。引数 `n` の値によって、返り値のベクトルの型（長さ）が決まるからです。

---

#### 2.3 Σ型 (Dependent Pair Types)

**Σ型 (シグマがた)** は、依存型を持つペア（組）、すなわち**ペアの2番目の要素の型が、1番目の要素の値に依存するようなペア**の型です。`Σx:A. B(x)` と表記されます。

* **`x:A`**: ペアの1番目の要素 `x` とその型 `A` を示します。
* **`B(x)`**: ペアの2番目の要素の型です。この型 `B` が1番目の要素 `x` の値に応じて変化することを示します。

Σ型の項は、`(a, b)` というペアで、ここで `a` は型 `A` を持ち、`b` は型 `B(a)` を持ちます。

**単純な積型 `×` との関係**

STLCにおける積型（ペアの型） `A × B` は、Σ型の特別な場合です。つまり、2番目の要素の型 `B` が1番目の要素 `x` の値に**依存しない**場合です。

$$A \times B \equiv \Sigma x:A. B \quad (\text{ただし、} B \text{は} x \text{に依存しない})$$

**カリー・ハワード同型対応: 存在量化 (∃)**

Σ型は、論理における**存在量化子 (∃, "there exists")** に対応します。

`Σx:A. B(x)` という型を持つ項（ペア）を構築することは、
**「命題 `B(x)` を満たすような `x:A` が存在する」(`∃x:A. B(x)`)**
という命題を証明することに対応します。

なぜなら、この型の項 `(a, p)` は、条件を満たす具体的な「証拠物件」`a`（**witness** と呼びます）と、その `a` が確かに条件 `B(a)` を満たしていることの「証明」`p` をペアにして提示しているからです。

**例:**
* 「偶数であるような自然数が存在する」という命題を型で表現してみましょう。「`n`は偶数である」という命題を `IsEven(n)` という型で表すと、この命題全体は `Σn:Nat. IsEven(n)` というΣ型で表現できます。
* この型の項（証明）は、例えば `(4, p)` のようなペアになります。ここで `4` は具体的な偶数（witness）であり、`p` は `4` が偶数であることの証明 (`IsEven(4)` 型の項）です。

---

### 演習

**例題1: 依存型か、単純型か？**

以下の説明文が表す「型」は、依存型（Π型やΣ型が必要）でしょうか、それとも単純型（単純な関数型 `->` や積型 `×` で十分）でしょうか？理由とともに答えてください。

1.  2つの整数を受け取り、その和を返す関数の型。
2.  自然数 `n` を受け取り、「`n`は素数である」ことの証明を返す関数の型。
3.  ユーザーID（文字列）と、そのユーザーの最新のログイン日時（タイムスタンプ）をペアにしたデータの型。
4.  ファイルの種類（例: "JPG", "TXT"）と、その種類に応じたメタデータ（JPGなら画像サイズ、TXTなら文字コードなど）をペアにしたデータの型。

**解答と解説1:**

1.  **単純型**
    * **型**: `Integer -> Integer -> Integer`
    * **理由**: 返り値の型（`Integer`）は、引数の値に依存しません。どんな整数を受け取っても、返り値は常に整数型です。

2.  **依存型 (Π型)**
    * **型**: `Πn:Nat. IsPrime(n)` （`IsPrime(n)` は「nは素数である」という命題を表す型）
    * **理由**: 返り値の型 `IsPrime(n)` は、引数 `n` の値に依存します。`IsPrime(3)` と `IsPrime(5)` は異なる型（異なる命題の証明）です。この関数が構成できるのは、`n` が素数の場合のみでしょう（非素数の `n` に対しては、この型の値を返すことは不可能です）。

3.  **単純型**
    * **型**: `String × Timestamp`
    * **理由**: ペアの2番目の要素（タイムスタンプ）の型は、1番目の要素（ユーザーID）の値に依存しません。どのユーザーIDに対しても、ログイン日時は同じタイムスタンプ型です。

4.  **依存型 (Σ型)**
    * **型**: `Σkind:FileType. Metadata(kind)` （`FileType`はファイル種別の型、`Metadata(kind)`は種類`kind`に応じたメタデータの型）
    * **理由**: ペアの2番目の要素であるメタデータの型 `Metadata(kind)` は、1番目の要素であるファイルの種類 `kind` の値に依存します。`kind`が"JPG"なら`Metadata("JPG")`は画像サイズ（例: `Integer × Integer`）、`kind`が"TXT"なら`Metadata("TXT")`は文字コード（例: `String`）といったように、型が変わります。

---

**例題2: Π型か、Σ型か？**

以下のシナリオを型でモデル化する場合、Π型とΣ型のどちらがより適切でしょうか？その理由と、型の概略を記述してください。

1.  「空でない自然数のリスト」を表現するデータ構造。
2.  どんな自然数 `n` が与えられても、長さが `2*n` のベクトルを返すことができる、という事実を保証する関数の型。
3.  ある数が「完全数（その数自身を除く約数の和が、その数自身と等しい自然数）」であることを示す証拠。

**解答と解説2:**

1.  **Σ型**
    * **理由**: 「空でない」という存在を表現したいからです。「ある長さ `n` が存在し、そのリストは長さ `n+1` である」と考えることができます。
    * **型の概略**: `Σn:Nat. Vec A (n + 1)`
    * **解説**: この型の項は `(n, v)` というペアです。ここで `v` は `Vec A (n+1)` 型のベクトルです。`n` は自然数なので、`n+1` は常に1以上です。つまり、この型のベクトル `v` は空でないことが保証されます。

2.  **Π型**
    * **理由**: 「どんな `n` に対しても（全称）」という性質を持つ関数を表現したいからです。
    * **型の概略**: `Πn:Nat. Vec A (2 * n)`
    * **解説**: この型を持つ関数は、任意の自然数 `n` を引数として受け取り、それに対して必ず `Vec A (2*n)` という型（要求された長さのベクトル）の値を返す能力があることを示しています。

3.  **Σ型**
    * **理由**: 「完全数が存在する」という事実を示したいので、その具体的な数（witness）と、それが完全数であることの証明をペアにするのが自然です。
    * **型の概略**: `Σn:Nat. IsPerfect(n)` （`IsPerfect(n)`は「`n`が完全数である」という命題を表す型）
    * **解説**: この型の項は、例えば `(6, p)` のようになります。`6` が具体的な完全数の例であり、`p` は `6` の約数 (1, 2, 3) の和が `6` であることの証明です。

---

**例題3: 型で安全性を保証する**

ベクトルの最初の要素を返す `head` 関数を考えます。空のベクトルに `head` を適用すると、エラーが発生するはずです。この「空でないベクトルにしか適用できない」という安全性を、`head` 関数の型シグネチャ自身で保証するには、どのように型を定義すればよいでしょうか？Π型を使ってみましょう。

**解答と解説3:**

この問題を解決する鍵は、「空でない」という条件を型レベルで表現することです。空でないベクトルとは、長さが `0` ではない、つまり `1` 以上のベクトルです。自然数 `n` を使えば、長さ `n+1` のベクトルは常に空でないと表現できます。

これを踏まえて、`head` 関数の型を次のように定義します。

**型の定義**:
$$\text{head} : \Pi n:\text{Nat}. \text{Vec } A (n+1) \rightarrow A$$

**解説**:

1.  **`Πn:Nat.`**: この関数は、まず「暗黙の」引数として自然数 `n` を取ります。この `n` は、ベクトルの長さを `n+1` と表現するために使われます。
2.  **`Vec A (n+1)`**: これが `head` 関数の主たる引数の型です。この型のおかげで、`head` 関数は**長さが `n+1` であるベクトルしか受け付けません**。`n` は `0` 以上の自然数なので、`n+1` は常に `1` 以上です。つまり、この関数に**空のベクトル（長さ0）を渡そうとすると、型エラーになります**。
3.  **`-> A`**: 返り値は、ベクトルの要素の型 `A` です。

**視点**:
この型定義は、関数の「事前条件（precondition）」、すなわち「この関数を呼び出すためには、引数のベクトルは空であってはならない」という条件を、型システムの一部として組み込んでいます。
プログラマーが誤って空のベクトルを `head` に渡すようなコードを書いた場合、それは実行時エラーではなく、**コンパイル時エラー**として検出されます。これこそが、依存型がもたらす「型による安全性保証」の強力な一例です。依存型を用いることで、プログラムの正しさに関する多くの性質を、実行前に静的に検証することが可能になるのです。

