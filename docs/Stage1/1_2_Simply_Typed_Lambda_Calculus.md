はい、承知いたしました。ステージ1の2番目のセクション「単純型付きラムダ計算」の教材を作成します。前回同様、概念の説明と多角的な例題・解説を組み合わせ、初学者でも理解を深められるように構成します。

---

### ステージ1: 型理論への誘いとラムダ計算の基礎

#### 2. 単純型付きラムダ計算 (Simply Typed Lambda Calculus)

イントロダクションでは、「型」という概念の広がりを見てきました。このセクションでは、その「型」と「計算」がどのように結びつくのか、その最も基本的で美しいモデルである**単純型付きラムダ計算 (Simply Typed Lambda Calculus, STLC)** を通して学んでいきましょう。

ラムダ計算は、「計算とは何か？」という根源的な問いに答えるために、1930年代に数学者アロンゾ・チャーチによって考案された非常にシンプルな計算体系です。驚くべきことに、関数定義と関数呼び出しというたった2つの基本操作だけで、現代のコンピュータで実行可能なあらゆる計算を表現できる能力を持っています（※これは型のないラムダ計算の話で、チューリング完全性と呼ばれます）。

この強力な計算モデルに「型」の概念を導入したのがSTLCです。STLCを学ぶことで、以下の重要な概念を理解できます。

* プログラム（関数）とデータ（値）の厳密な表現方法
* プログラムが「正しい型を持つ」とはどういうことか
* 型システムがプログラムにどのような性質（特に「停止性」）をもたらすか
* 計算と論理の驚くべき対応関係（カリー・ハワード同型対応）への第一歩

難しそうに聞こえるかもしれませんが、一つ一つの要素はとてもシンプルです。まずは、型を一旦忘れて、ラムダ計算の基本的な仕組みから見ていきましょう。

---

#### 2.1 ラムダ計算の基本

型のないラムダ計算の構成要素（**ラムダ項** または **項** と呼びます）は、たったの3種類しかありません。

1.  **変数 (Variable)**: `x`, `y`, `z`, ...
    * 値や式に名前をつけるためのものです。プログラミング言語の変数と同じです。

2.  **ラムダ抽象 (Lambda Abstraction)**: `λx. M`
    * 「引数 `x` を受け取って、式 `M` を返す関数」を定義する方法です。`λ` はギリシャ文字のラムダです。
    * `λx.` の部分が引数の宣言、`.` の後にある `M` が関数の本体（**body**）です。
    * 例えば、`λx. x + 1` は、数値 `x` を受け取って `x+1` を返す関数（いわゆるインクリメント関数）を表現していると考えることができます。

3.  **適用 (Application)**: `M N`
    * 関数 `M` を引数 `N` で呼び出す（適用する）ことです。
    * 例えば、`inc = λx. x + 1` とすると、`inc 5` は `inc` という関数に `5` を適用すること、つまり `5 + 1` を計算することを意味します。

これだけです！ この3つのルールを組み合わせることで、複雑なプログラムを組み立てていきます。例えば、`λf. λx. f (f x)` という項は、「関数 `f` と値 `x` を受け取り、`x` に `f` を2回適用する」という高階関数を表します。

**束縛変数と自由変数**

ラムダ計算では、変数が `λ` によって束縛されているかどうかが重要です。

* `λx. M` という式において、`x` はこの式の中で**束縛変数 (bound variable)** となります。関数の仮引数のようなものです。
* `λ` に束縛されていない変数は**自由変数 (free variable)** と呼ばれます。グローバル変数のように、式の外から値が与えられる必要があります。

例: `λx. x y` という項において、
* `x` は `λx` によって束縛されている**束縛変数**です。
* `y` はどこにも束縛されていない**自由変数**です。

---

#### 2.2 計算ルール: β簡約とη変換

ラムダ計算の「計算」は、項をより単純な形に書き換えるルールによって定義されます。最も重要なルールが **β簡約 (beta reduction)** です。

**β簡約**

β簡約は、関数適用を実際に行う計算です。
`(λx. M) N` という形の項（ラムダ抽象に関数を適用している形）は、`M` の中に出現するすべての束縛変数 `x` を項 `N` で置き換えたものに書き換えることができます。この操作を `M[x := N]` と書きます。

$$(\lambda x. M) N \rightarrow_\beta M[x := N]$$

これがラムダ計算における唯一の基本的な計算ステップです。

**例:**
* `(λx. x + 1) 5`
    * これは `(x + 1)[x := 5]` となり、`5 + 1` に簡約されます。
* `(λf. λx. f x) (λy. y + 1) z`
    1.  まず、外側の適用 `(λf. ...) (λy. ...)` を簡約します。
    2.  `f` を `(λy. y + 1)` で置き換えるので、 `(λx. f x)[f := (λy. y + 1)]` となり、 `λx. (λy. y + 1) x` となります。
    3.  次に、内側の適用 `(λy. y + 1) x` を簡約します。
    4.  `y` を `x` で置き換えるので、`(y + 1)[y := x]` となり、`x + 1` となります。
    5.  最終的に、`λx. x + 1` という「インクリメント関数」そのものに簡約されました。

**η変換**

もう一つ、**η変換 (eta conversion)** というルールがあります。これは関数の「外延性（extensionality）」に関わるもので、「2つの関数が、任意の入力に対して同じ出力を返すならば、それらは同じ関数である」という考え方を反映しています。

$$\lambda x. M x \leftrightarrow_\eta M \quad (\text{ただし } x \text{ は } M \text{ の中に自由変数として現れない})$$

これは、`λx. M x` （`x` を受け取って `M` に適用する関数）は、元の `M` と同じ振る舞いをするので、同一視できる、ということを意味します。β簡約ほど計算の中心ではありませんが、理論上重要な役割を果たします。

---

#### 2.3 型の導入: 単純型付きラムダ計算 (STLC)

型のないラムダ計算は非常に強力ですが、問題点もあります。例えば、`Ω = (λx. x x) (λx. x x)` という項を考えてみましょう。これをβ簡約すると、`(x x)[x := (λx. x x)]` となり、自分自身 `(λx. x x) (λx. x x)` に戻ってしまいます。つまり、この計算は永久に停止しません。

このような問題を防ぎ、プログラムの正しさを保証するために「型」を導入します。STLCでは、すべての項が特定の型を持つように強制します。

**1. 型の構文**

STLCにおける型は、以下のように再帰的に定義されます。

* **基本型 (Base Types)**: `A`, `B`, `ι`, `ο` など、あらかじめ定められた基本的な型。整数型、ブーリアン型などを想定してください。
* **関数型 (Function Types)**: もし `σ` と `τ` が型ならば、`σ -> τ` も型です。これは「型 `σ` の値を受け取り、型 `τ` の値を返す関数」の型を表します。

**2. 型付け規則**

ある項 `M` が型 `σ` を持つことを `M : σ` と書きます。これを**型判断 (typing judgment)** と呼びます。しかし、自由変数を含む項の型は、その自由変数の型に依存します。そこで、自由変数の型を宣言する文脈として**型環境 (typing context)** `Γ`（ガンマ）を導入します。`Γ` は `x1: σ1, x2: σ2, ...` のような変数の型宣言のリストです。

`Γ ⊢ M : σ` は、「型環境 `Γ` のもとで、項 `M` は型 `σ` を持つ」と読みます。この型判断を導出するためのルールが**型付け規則**です。STLCの型付け規則は3つあります。

* **(VAR) 変数規則**:
    変数 `x` の型は、型環境 `Γ` で宣言されている通りである。
    $$
    \frac{}{\Gamma, x:\sigma \vdash x : \sigma}
    $$

* **(ABS) 抽象規則**:
    もし、`x` に型 `σ` を仮定した環境で、`M` が型 `τ` を持つならば、`λx:σ. M` は型 `σ -> τ` を持つ。
    （ラムダ抽象の引数にも型注釈 `λx:σ` が付くことに注意）
    $$
    \frac{\Gamma, x:\sigma \vdash M : \tau}{\Gamma \vdash (\lambda x:\sigma. M) : \sigma \rightarrow \tau}
    $$

* **(APP) 適用規則**:
    もし、`M` が関数型 `σ -> τ` で、`N` がその引数の型 `σ` を持つならば、適用 `M N` は返り値の型 `τ` を持つ。
    $$
    \frac{\Gamma \vdash M : \sigma \rightarrow \tau \quad \Gamma \vdash N : \sigma}{\Gamma \vdash (M N) : \tau}
    $$

これらのルールを組み合わせることで、複雑な項の型を導き出すことができます。そして、重要なのは、**型付け可能な項は必ず計算が停止する**ということです。

#### 2.4 重要な性質

**強く正規化する性質 (Strong Normalization)**

STLCの最も重要な性質の一つです。これは、「型付け可能な（well-typedな）ラムダ項は、どのようにβ簡約を進めても、いつかはそれ以上簡約できない形（**正規形**）に必ず到達する」というものです。つまり、**STLCで書かれたプログラムは無限ループに陥らない**ことが保証されています。
これにより、型のないラムダ計算で可能だった `(λx. x x)(λx. x x)` のような項は、STLCでは型付けできない（排除される）ことになります。

**カリー・ハワード同型対応への導入**

型付け規則をもう一度見てみましょう。

* (APP) `σ -> τ` と `σ` から `τ` を得る。
* (ABS) `σ` を仮定して `τ` を導ければ、`σ -> τ` を結論できる。

これは、論理学における推論規則と非常によく似ています。

* **モーダスポネンス**: `P ⇒ Q` と `P` が真なら、`Q` も真である。
* **含意導入**: `P` を仮定して `Q` が証明できるなら、`P ⇒ Q` は真である。

この驚くべき対応関係は**カリー・ハワード同型対応 (Curry-Howard Isomorphism)** と呼ばれ、型理論の根幹をなすアイデアです。

| 型理論 (STLC) | 論理学 (直観主義論理) |
| :--- | :--- |
| 型 (`σ`, `τ`) | 命題 (`P`, `Q`) |
| 関数型 (`σ -> τ`) | 含意 (`P ⇒ Q`) |
| 項 (`M`) | 証明 |
| `M : σ` (項Mは型σを持つ) | Mは命題Pの証明である |
| 型を持つ項が存在する | 命題は証明可能（真）である |

この対応によれば、ある型を持つ項を構築することは、その型に対応する論理式を証明することと全く同じことになります。例えば、`λx:A. x` という項は `A -> A` という型を持ちますが、これは `A ⇒ A` という（常に真である）論理式の証明に対応しているのです。

---

### 演習

**例題1: β簡約の練習**

以下のラムダ項を、それ以上簡約できなくなるまでβ簡約してください。

1.  `(λx:A. λy:B. x) (λz:C. z) w`  (ここで `w` は型Bの変数とします)
2.  `(λf:A->A. λx:A. f (f x)) (λy:A. y) z` (ここで `z` は型Aの変数とします)

**解答と解説1:**

1.  `(λx:A. λy:B. x) (λz:C. z) w`
    * **Step 1**: 最初の適用 `(λx:A. λy:B. x) (λz:C. z)` を簡約します。`x` を `(λz:C. z)` で置き換えます。
        * ` (λy:B. x)[x := (λz:C. z)] `
        * `λy:B. (λz:C. z)` となります。
    * **Step 2**: 簡約後の式 `(λy:B. (λz:C. z)) w` を考えます。`w` を適用します。
        * ` (λz:C. z)[y := w] `
        * `y` は本体 `(λz:C. z)` の中に自由変数として出現しないため、置き換えは起こりません。
        * 結果は `λz:C. z` となります。
    * **最終結果**: `λz:C. z` (これは恒等関数です)
    * **視点**: この計算は、2つの引数を受け取って1つ目の引数を返す関数（プログラミング言語の `const` や `fst` に似ています）に、2つの引数を渡していることに相当します。結果として1つ目の引数（ここでは恒等関数 `λz:C. z`）が返されました。

2.  `(λf:A->A. λx:A. f (f x)) (λy:A. y) z`
    * **Step 1**: 最初の適用 `(λf:A->A. ...) (λy:A. y)` を簡約します。`f` を `(λy:A. y)`（型Aの恒等関数）で置き換えます。
        * ` (λx:A. f (f x))[f := (λy:A. y)] `
        * `λx:A. (λy:A. y) ((λy:A. y) x)` となります。
    * **Step 2**: 簡約後の式 `(λx:A. (λy:A. y) ((λy:A. y) x)) z` を考えます。
        * 先に `(λy:A. y) x` を簡約します。これは `x` になります。
        * すると、`λx:A. (λy:A. y) x` となります。
        * これも同様に簡約すると `λx:A. x` となります。
    * **Step 3**: `(λx:A. x) z` を簡約します。
        * `x[x := z]` となり、`z` になります。
    * **最終結果**: `z`
    * **視点**: この計算は、「関数を2回適用する関数」に「何もしない関数（恒等関数）」を渡しています。その結果は当然「何もしない関数」になります。それに引数 `z` を適用したので、最終的に `z` がそのまま返ってきました。

---

**例題2: 型を導出してみよう**

型環境 `Γ = f:A->(B->C), g:A->B, x:A` のもとで、項 `f x (g x)` がどのような型を持つか、型付け規則に従って導出（証明）してください。

**解答と解説2:**

この導出は、型付け規則を証明図の形で下から上へ（ゴールから前提へ）と読んでいくと分かりやすいです。

**ゴール**: `Γ ⊢ f x (g x) : ?`

1.  一番外側の構造は `(f x)` と `(g x)` の適用です。なので、(APP)規則を使うはずです。
    * `f x` は関数で、`g x` はその引数です。
    * (APP) `Γ ⊢ f x : ?1 -> ?2`
    * (APP) `Γ ⊢ g x : ?1`
    * ならば `Γ ⊢ (f x) (g x) : ?2` となります。

2.  `Γ ⊢ f x : ?1 -> ?2` の型を調べます。これも適用なので(APP)規則を使います。
    * (APP) `Γ ⊢ f : ?3 -> (?1 -> ?2)`
    * (APP) `Γ ⊢ x : ?3`
    * `Γ` を見ると `f: A->(B->C)` なので、`?3`は`A`、`?1`は`B`、`?2`は`C`だと分かります。
    * (VAR) `Γ ⊢ f : A->(B->C)` （環境にある）
    * (VAR) `Γ ⊢ x : A` （環境にある）
    * よって、(APP)規則から `Γ ⊢ f x : B -> C` が導けます。

3.  `Γ ⊢ g x : ?1` の型を調べます。これも適用です。
    * (APP) `Γ ⊢ g : ?4 -> ?1`
    * (APP) `Γ ⊢ x : ?4`
    * `Γ` を見ると `g: A->B` なので、`?4`は`A`、`?1`は`B`だと分かります。
    * (VAR) `Γ ⊢ g : A->B` （環境にある）
    * (VAR) `Γ ⊢ x : A` （環境にある）
    * よって、(APP)規則から `Γ ⊢ g x : B` が導けます。

4.  **まとめ**:
    * ステップ2から `Γ ⊢ f x : B -> C`
    * ステップ3から `Γ ⊢ g x : B`
    * これらをステップ1の `?1`, `?2` に当てはめると、`?1=B`, `?2=C` となります。
    * したがって、最後の(APP)規則から `Γ ⊢ f x (g x) : C` が導けます。

**証明図:**
$$
\frac{
  \frac{
    \frac{}{\Gamma \vdash f : A \rightarrow (B \rightarrow C)} (VAR)
    \quad
    \frac{}{\Gamma \vdash x : A} (VAR)
  }{
    \Gamma \vdash f x : B \rightarrow C
  } (APP)
  \quad
  \frac{
    \frac{}{\Gamma \vdash g : A \rightarrow B} (VAR)
    \quad
    \frac{}{\Gamma \vdash x : A} (VAR)
  }{
    \Gamma \vdash g x : B
  } (APP)
}{
  \Gamma \vdash f x (g x) : C
} (APP)
$$

**視点**: このプロセスは、静的型付け言語のコンパイラが行う型チェックそのものです。コンパイラは、プログラムの各部分式がどのような型を持つかをボトムアップまたはトップダウンに解析し、矛盾がないか（例えば、`int` 型の値に関数を適用しようとしていないかなど）を検証します。

---

**例題3: 論理とプログラムの対応**

カリー・ハワード同型対応の考え方に基づき、以下の論理式に対応するラムダ項を構築し、その型を示してください。

1.  `A ⇒ (B ⇒ A)`
2.  `(A ⇒ B) ⇒ ((B ⇒ C) ⇒ (A ⇒ C))`

**解答と解説3:**

1.  **論理式**: `A ⇒ (B ⇒ A)`
    * **型に翻訳**: `A -> (B -> A)`
    * **思考プロセス**:
        1.  この型の項を作りたいので、`λx:A. ...` という形になるはずです。`x` は型 `A` を持ちます。
        2.  本体 `...` の部分で `B -> A` という型の項を作る必要があります。
        3.  `B -> A` 型の項は、`λy:B. ...` という形になるはずです。`y` は型 `B` を持ちます。
        4.  その本体 `...` の部分では、型 `A` の項を返す必要があります。
        5.  今、使える変数（手持ちのカード）は `x:A` と `y:B` です。型 `A` の項が欲しいので、`x` を使えばよいです。
    * **構築された項**: `λx:A. λy:B. x`
    * **検証**: この項は、引数を2つ（`x`と`y`）受け取り、1つ目の引数 `x` を返します。型は `A -> (B -> A)` となり、目標の型と一致します。
    * **論理的意味**: 「命題Aが真であると仮定すれば、その後、命題Bが真であると仮定したとしても、最初に仮定したAは依然として真である」という自明な論理を示しています。

2.  **論理式**: `(A ⇒ B) ⇒ ((B ⇒ C) ⇒ (A ⇒ C))`
    * **型に翻訳**: `(A -> B) -> ((B -> C) -> (A -> C))`
    * **思考プロセス**:
        1.  一番外側は `(A -> B)` を引数に取ります。なので `λf:A->B. ...` と始めます。`f` は `A` から `B` への関数です。
        2.  本体 `...` は `(B -> C) -> (A -> C)` という型を持つ必要があります。
        3.  なので、`λg:B->C. ...` と続きます。`g` は `B` から `C` への関数です。
        4.  その本体 `...` は `A -> C` という型を持つ必要があります。
        5.  なので、`λx:A. ...` と続きます。`x` は型 `A` の値です。
        6.  最後の本体 `...` では、型 `C` の値を返す必要があります。
        7.  今、使える手持ちのカードは `f:A->B`、`g:B->C`、`x:A` の3つです。
        8.  `x` は型 `A` なので、`f` に適用できます。`f x` は型 `B` の値になります。
        9.  `f x` は型 `B` なので、`g` に適用できます。`g (f x)` は型 `C` の値になります。これは求めていた型です！
    * **構築された項**: `λf:A->B. λg:B->C. λx:A. g (f x)`
    * **検証**: この項は、関数 `f`、関数 `g`、値 `x` を受け取り、`x` に `f` を適用し、その結果に `g` を適用します。これはまさに**関数の合成**です。
    * **論理的意味**: この命題は、論理推論における**三段論法**の一種（仮言三段論法）を表しています。「もしAならばBであり、かつ、もしBならばCであるならば、もしAならばCである」という推論規則そのものが、関数の合成というプログラムに対応しているのです。

**視点**: これらの例は、カリー・ハワード同型対応が単なる偶然のアナロジーではなく、論理的な推論の構造と、プログラム（特に関数）の組み合わせの構造が、深く本質的なレベルで同一であることを示唆しています。この洞察が、後のステージで学ぶ証明支援系の基礎となります。
